{"version":3,"sources":["index.js"],"names":["Card","props","suitClass","isSelected","concat","suit","className","id","onClick","src","process","name","alt","Hand","state","cardList","selectedList","Array","length","fill","i","this","value","image","playerid","tempList","slice","handList","push","renderCard","renderHand","React","Component","Pile","count","pileList","pileid","renderPile","Discard","discardList","discardid","String","renderDiscard","Board","renderPileList","renderHandList","renderDiscardList","Game","activePlayer","winner","roundNumber","roundScores","suitList","overflowNumber","numberList","numWilds","wildValue","maxRounds","wildPoints","selectedCard","handIndex","cardIndex","socket","io","on","newState","console","log","setState","emit","pileIndex","tempHandList","tempHand","tempCard","tempPileList","tempPile","tempCardList","tempDiscardList","splice","currentCount","tempState","handleTurnEnd","isActivePlayer","handleHandClick","handlePileClick","j","finalScores","indexOf","Math","max","apply","roundOver","handleRoundEnd","thisRound","scoreList","thisRoundList","topPlayers","mostCards","player","suitCardList","wildCards","pop","checkWinner","resetBoard","deck","tempDeck","randInt","floor","random","currentHand","orderedDeck","initializeDeck","shuffledDeck","shuffleDeck","playerHands","dealCards","initializePiles","initializeDiscards","winnerNumber","map","scoreArray","score","scoreIndex","playerHandList","suitOrder","onTurnEnd","ReactDOM","render","onUpdate","window","scrollTo","path","component","document","getElementById"],"mappings":"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","file":"static/js/main.95938348.chunk.js","sourcesContent":["import React, {useContext, useState, useEffect} from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\n\r\nimport { BrowserRouter as Router, Route, Redirect, useLocation} from 'react-router-dom';\r\nimport io from \"socket.io-client\";\r\n\r\nconst serverPath = 'localhost:5000';\r\n\r\n\r\nfunction Card(props) {\r\n  let suitClass = (props.isSelected ? \"isSelected \" : \"\").concat(props.suit)\r\n  return (\r\n    <div className=\"cardHolder\">\r\n      <button className={suitClass + \" card\"} id={props.id} onClick={props.onClick}>\r\n        {<img src={process.env.PUBLIC_URL + \"/images/\" + props.name + \".jpg\"}  alt={props.name}/>}\r\n      </button>\r\n    </div>\r\n    \r\n  );\r\n}\r\n\r\nclass Hand extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            //Don't think we actually need this in state \r\n            //playerNumber = null,\r\n            cardList: this.props.cardList,\r\n            selectedList: Array(this.props.cardList.length).fill(false),\r\n        };\r\n    }\r\n    //Given a list of cards, render it within the hand (by iteratively calling the renderCard function)\r\n    //pretty sure we'll want to put RenderCard in each class, so that it can get passed different onclick methods based on its parent\r\n    renderCard(i) {\r\n      return (\r\n        <li key={\"Card\".concat(this.props.cardList[i].id)}> \r\n          <Card \r\n            id={this.props.cardList[i].id}\r\n            name={this.props.cardList[i].name}\r\n            value={this.props.cardList[i].value}\r\n            suit={this.props.cardList[i].suit}\r\n            image={this.props.cardList[i].name}\r\n            isSelected={this.props.cardList[i].isSelected}\r\n            onClick={() => this.props.onClick(this.props.playerid, i)}\r\n          />\r\n        </li>\r\n      );\r\n    }\r\n    \r\n    \r\n    renderHand() {\r\n      let tempList = this.props.cardList.slice();\r\n      let i, handList = [];\r\n      for (i = 0; i < tempList.length; i++) {\r\n        handList.push( this.renderCard(i) );\r\n      }\r\n      return (\r\n        handList\r\n      );\r\n    }\r\n    \r\n    render() {\r\n        return (\r\n            <div className=\"hand\" playerid={this.props.playerid}>\r\n                <ul>{this.renderHand()}</ul>\r\n            </div>\r\n        );\r\n    }\r\n}  \r\n\r\nclass Pile extends React.Component {\r\n  constructor(props) {\r\n      super(props);\r\n      this.state = {\r\n          //Don't think we actually need this in state \r\n          //playerNumber = null,\r\n          cardList: this.props.cardList,\r\n          count: this.props.count,\r\n      };\r\n  }\r\n  //Given a list of cards, render it within the hand (by iteratively calling the renderCard function)\r\n  //pretty sure we'll want to put RenderCard in each class, so that it can get passed different onclick methods based on its parent\r\n  renderCard(i) {\r\n      return (\r\n        <li key={\"Card\".concat(this.props.cardList[i].id)}> \r\n          <Card \r\n            id={this.props.cardList[i].id}\r\n            name={this.props.cardList[i].name}\r\n            value={this.props.cardList[i].value}\r\n            suit={this.props.cardList[i].suit}\r\n            image={this.props.cardList[i].name}\r\n            isSelected={this.props.cardList[i].isSelected}\r\n            //Pile doesn't need an onClick for the card -- just for the pile itself\r\n            onClick={() => null} //this.props.onClick()}\r\n          />\r\n        </li>\r\n      );\r\n    }\r\n  \r\n  \r\n  renderPile() {\r\n    let tempList = this.props.cardList.slice();\r\n    let i, pileList = [];\r\n    for (i = 0; i < tempList.length; i++) {\r\n      pileList.push( this.renderCard(i) );\r\n    }\r\n    return(\r\n      pileList\r\n    );\r\n  }\r\n  \r\n  render() {\r\n    const className = this.props.suit + \" pile\";\r\n      return (\r\n          <div className={className} pileid={this.props.pileid} onClick={() => this.props.onClick(this.props.pileid)}>\r\n            <div className=\"pileNameHolder\">\r\n              {this.props.suit + \" : \" + this.props.count}\r\n            </div>\r\n              <ul>{this.renderPile()}</ul>\r\n          </div>\r\n      );\r\n  }\r\n}  \r\n\r\nclass Discard extends React.Component {\r\n  constructor(props) {\r\n      super(props);\r\n      this.state = {\r\n          //Don't think we actually need this in state \r\n          //playerNumber = null,\r\n          cardList: this.props.cardList,\r\n          count: this.props.count,\r\n      };\r\n  }\r\n  //Given a list of cards, render it within the hand (by iteratively calling the renderCard function)\r\n  //pretty sure we'll want to put RenderCard in each class, so that it can get passed different onclick methods based on its parent\r\n  renderCard(i) {\r\n      return (\r\n        <li key={\"Card\".concat(this.props.cardList[i].id)}> \r\n          <Card \r\n            id={this.props.cardList[i].id}\r\n            name={this.props.cardList[i].name}\r\n            value={this.props.cardList[i].value}\r\n            suit={this.props.cardList[i].suit}\r\n            image={this.props.cardList[i].name}\r\n            isSelected={this.props.cardList[i].isSelected}\r\n            //No onClick for the discard pile\r\n            //onClick={i => this.props.onClick(i)}\r\n          />\r\n        </li>\r\n      );\r\n    }\r\n  \r\n  \r\n  renderDiscard() {\r\n    let tempList = this.props.cardList.slice();\r\n    let i, discardList = [];\r\n    for (i = 0; i < tempList.length; i++) {\r\n      discardList.push( this.renderCard(i) );\r\n    }\r\n    return(\r\n      discardList\r\n    );\r\n  }\r\n  \r\n  render() {\r\n    const className = this.props.discardid + \" discard\";\r\n      return (\r\n          <div className={className} discardid={this.props.discardid}>\r\n            <div className=\"discardNameHolder\">\r\n              {\"Player \" + String(this.props.discardid) + \" Discard\"}\r\n            </div>\r\n            <ul>{this.renderDiscard()}</ul>\r\n            \r\n            <div className=\"discardCountHolder\">\r\n              {\"Count: \" + String(this.props.count)}\r\n            </div>\r\n          \r\n          </div>\r\n      );\r\n  }\r\n}  \r\n\r\nclass Board extends React.Component {\r\n  render() {\r\n    return (\r\n      <div className=\"gameBoard\">\r\n        <div className=\"pileList\">\r\n          <ul>{this.props.renderPileList()}</ul>\r\n        </div>\r\n        <div className=\"handList\">\r\n          <ul>{this.props.renderHandList()}</ul>\r\n        </div>\r\n        <div className=\"discardList\">\r\n          <ul>{this.props.renderDiscardList()}</ul>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nclass Game extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      name: \"twocat\",\r\n      activePlayer: 0, \r\n      winner: null,\r\n      roundNumber: 0, \r\n      roundScores: Array(4).fill(Array(4).fill(0)),\r\n      suitList : [\"Cat\", \"Mirror\", \"Ladder\"],\r\n      overflowNumber : 14, //This means it can be UPTO 13, and goes away at 14\r\n      numberList : [1, 1, 1, 2, 2, 2, 4, 4, 5, 5, 5, 7, 7, 7],\r\n      numWilds : 8,\r\n      wildValue : 4,\r\n      maxRounds : 4,\r\n      wildPoints : 2,\r\n      //Moving this up from Board to Game class\r\n      handList: null,\r\n      pileList: null,\r\n      discardList: null,\r\n      selectedCard: {\r\n        handIndex: null,\r\n        cardIndex: null,\r\n      },\r\n    };\r\n\r\n    /*\r\n  let {pathname, search} = useLocation();\r\n  this.gameName = pathname.slice(1,);\r\n  console.log(\"NAME: \", gameName);\r\n  */\r\n this.socket = io(serverPath);\r\n this.socket.on('UPDATE_STATE', (newState) => {\r\n   console.log(\"UPDATE STATE ON 237\");\r\n   this.setState(newState);\r\n   });\r\n  \r\n  \r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.socket.emit('REMOVE_PLACE', this.state.name);\r\n  }\r\n  //Bringing these functions up from Board to Game----------\r\n  handlePileClick(pileIndex) {\r\n    //First check to make sure a card is selected before acting on a Pile Click\r\n    let selectedCard = this.state.selectedCard;\r\n    let activePlayer = this.state.activePlayer;\r\n\r\n    //We gotta check whether there's a currently selected card\r\n    if (selectedCard.cardIndex == null || selectedCard.handIndex == null) {\r\n      //And if not, then we're not doing ANYTHANG\r\n      return;\r\n    }\r\n    \r\n    //Theoretically this code should be unreachable, because no selected card should belong to a player other than the active player, but who knows...\r\n    if (selectedCard.handIndex !== activePlayer) {\r\n      return;\r\n    } \r\n\r\n    //get copies of all the relevant data\r\n    let handIndex = selectedCard.handIndex;\r\n    let cardIndex = selectedCard.cardIndex;\r\n    let tempHandList = this.state.handList.slice();\r\n    let tempHand = tempHandList[handIndex].slice();\r\n    let tempCard = tempHand[cardIndex];\r\n\r\n    let tempPileList = this.state.pileList.slice();\r\n    let tempPile = tempPileList[pileIndex];\r\n    let tempCardList = tempPile.cardList.slice();\r\n\r\n    //We need these so that we can modify the discard state if needed\r\n    let tempDiscardList = this.state.discardList.slice();\r\n    \r\n\r\n\r\n    //One final check to see if the current card CAN be placed on the selected Pile:\r\n    if (tempCard.suit !== tempPile.suit && tempCard.suit !== \"Wild\") {\r\n      return;\r\n    }\r\n\r\n    //Alright, it's a valid move, now let's get this card PLAYED!\r\n    //Remove the card from the hand and update the hand\r\n    tempCard = tempHand.splice(cardIndex, 1)[0];\r\n    tempHandList[handIndex] = tempHand;\r\n\r\n    //Check the count of the pile\r\n    let currentCount = tempPile.count;\r\n\r\n    //Check whether the new card would put pile over the edge\r\n    if (currentCount + tempCard.value < this.state.overflowNumber) { \r\n      //If we're good, just push that card, and set state for the new pile cardlist and update the count\r\n      tempCardList.push(tempCard);\r\n      currentCount += tempCard.value;\r\n      \r\n    } else {\r\n      //Otherwise we need to discard the current cards in the pile, clear the pile and add the new card\r\n      tempDiscardList[handIndex].cardList = tempCardList.concat(tempDiscardList[handIndex].cardList);\r\n      tempDiscardList[handIndex].count += tempCardList.length;\r\n\r\n      tempCardList = [tempCard];\r\n      currentCount = tempCard.value;\r\n    }\r\n\r\n    //Now aggregate up the data structures\r\n    tempPile.cardList = tempCardList;\r\n    tempPile.count = currentCount;\r\n\r\n    tempPileList[pileIndex] = tempPile;\r\n\r\n    //And finally put Selected Card back to null, before writing state:\r\n    selectedCard = {\r\n      handIndex: null,\r\n      cardIndex: null,\r\n    };\r\n\r\n    //Finally set the state regardless of what happened\r\n    /*this.setState({\r\n      pileList: tempPileList,\r\n      discardList: tempDiscardList,\r\n      handList: tempHandList,\r\n      selectedCard: selectedCard,\r\n    });*/\r\n\r\n    //Update the server\r\n    let tempState = {\r\n      ...this.state,\r\n      pileList: tempPileList,\r\n      discardList: tempDiscardList,\r\n      handList: tempHandList,\r\n      selectedCard: selectedCard,\r\n    };\r\n    this.socket.emit(\"CHANGE_STATE\", tempState);\r\n\r\n    //And call the Game class method of ending the turn\r\n    this.handleTurnEnd(tempHandList, tempDiscardList);\r\n    return;\r\n\r\n  }\r\n\r\n  handleHandClick(handIndex, cardIndex) {\r\n    //So i is the hand id and j is the card index in the hand\r\n    let tempHandList = this.state.handList.slice();\r\n    let activePlayer = this.state.activePlayer;\r\n\r\n    //First check if it's a card in the hand of the selected player\r\n    if (handIndex !== activePlayer) {\r\n      return;\r\n    }\r\n    //We'll need these to make sure we take care of the selected values\r\n    let selectedCard = this.state.selectedCard;\r\n\r\n    //Before we do anything, we gotta check whether there's a currently selected card\r\n    if (selectedCard.cardIndex != null && selectedCard.handIndex != null) {\r\n      //And if so, we gotta set that card's isSelected attribute to false\r\n      tempHandList[selectedCard.handIndex][selectedCard.cardIndex].isSelected = false;\r\n    }\r\n\r\n    //Now set the new card's value to selected\r\n    let tempHand = tempHandList[handIndex].slice();\r\n    tempHand[cardIndex].isSelected = true;\r\n \r\n    //Set the selectedCard state to be the new hand/card index\r\n    selectedCard = {\r\n      handIndex: handIndex,\r\n      cardIndex: cardIndex,\r\n    };\r\n    \r\n    //Reaggregate the objects\r\n    tempHandList[handIndex] = tempHand;\r\n\r\n    \r\n\r\n    //Finally set the state regardless of what happened\r\n    /*this.setState({\r\n      handList: tempHandList,\r\n      selectedCard: selectedCard,\r\n    });*/\r\n\r\n    //Update the server\r\n    let tempState = {\r\n      ...this.state,\r\n      handList: tempHandList,\r\n      selectedCard: selectedCard,\r\n    };\r\n    this.socket.emit(\"CHANGE_STATE\", tempState);\r\n\r\n    return;\r\n  }\r\n    \r\n  // We'll need three render functions as well as three onClicks for each of the cards in the piles... Not ENTIRELY sure if those should be defined in this class or the Game class\r\n  renderHand(i){\r\n    let isActivePlayer = (i === this.state.activePlayer) ? \"active-player\" : \"inactive-player\";\r\n    let className = \"handHolder\".concat(\" \").concat(isActivePlayer); \r\n    \r\n    return ( \r\n      <li className=\"hand\" key={\"Hand\".concat(String(i))}>\r\n        <div className={className}>\r\n          <Hand \r\n            className={isActivePlayer}\r\n            playerid={i}\r\n            cardList={this.state.handList[i]}\r\n            onClick={(i, cardIndex) => this.handleHandClick(i, cardIndex)}\r\n          />\r\n        </div>\r\n      </li>\r\n    );\r\n  }\r\n  renderPile(i){\r\n    let className = \"pileHolder\";\r\n    return ( \r\n      <li className=\"pile\" key={\"Pile\".concat(String(i))}>\r\n        <div className={className}>\r\n          <Pile \r\n            pileid={i}\r\n            suit={this.state.pileList[i].suit}\r\n            count={this.state.pileList[i].count}\r\n            cardList={this.state.pileList[i].cardList}\r\n            onClick={(i) => this.handlePileClick(i)}\r\n          />\r\n        </div>\r\n      </li>\r\n    );\r\n  }\r\n  renderDiscard(i){\r\n    let className = \"discardHolder\";\r\n    return ( \r\n      <li className=\"discard\" key={\"Discard\".concat(String(i))}>\r\n        <div className={className}>\r\n          <Discard \r\n            discardid={i}\r\n            count={this.state.discardList[i].count}\r\n            cardList={this.state.discardList[i].cardList}\r\n            //I don't think we need this...\r\n            //onclick={() => this.handleDiscardClick()}\r\n          />\r\n        </div>\r\n      </li>\r\n    );\r\n  }\r\n \r\n  //Now this is the function that creates all the fucking things\r\n  renderPileList(){\r\n    //First render the three piles (including an empty one)\r\n    //Then render the discards\r\n    //Then the hands\r\n    let i, pileList = [];\r\n    if (this.state.pileList !== null) {\r\n      for (i = 0; i < this.state.pileList.length; i++) {\r\n        pileList.push( this.renderPile(i) );\r\n      } \r\n    }\r\n    return(\r\n      pileList\r\n    );\r\n  }\r\n\r\n  renderHandList() {\r\n    let i, handList = [];\r\n    if (this.state.handList !== null) {\r\n      for (i = 0; i < this.state.handList.length; i++) {\r\n        handList.push( this.renderHand(i) );\r\n      }\r\n    }\r\n    return(\r\n      handList\r\n    );\r\n  }\r\n\r\n  renderDiscardList(){\r\n    let i, discardList = [];\r\n    if (this.state.discardList !== null) {\r\n      for (i = 0; i < this.state.discardList.length; i++) {\r\n        discardList.push( this.renderDiscard(i) );\r\n      }   \r\n    }\r\n    return(\r\n      discardList\r\n    );\r\n  }\r\n  //End of functions brought up from Board to Game -------------\r\n\r\n\r\n  checkWinner() {\r\n    //Assuming the game IS over, let's check the scores and return the winning player\r\n    let finalScores = [0, 0, 0, 0];\r\n    let i, j;\r\n    for (i = 0; i < this.state.roundScores.length; i++) {\r\n      for (j = 0; j < this.state.roundScores[i].length; j++) {\r\n        finalScores[j] += this.state.roundScores[i][j];\r\n      }\r\n    }\r\n\r\n    return finalScores.indexOf( Math.max.apply(null, finalScores) );\r\n\r\n  };\r\n\r\n//This should check if it's the end of the round, and if so call handleRoundEnd, which will check if it's the end of the game, otherwise increment the activePlayer\r\n  handleTurnEnd(handList, discardList) {\r\n    let tempHandList = handList.slice();\r\n    let tempDiscardList = discardList.slice();\r\n\r\n    let roundOver = true;\r\n    //First we need to check to see if everyone's played all their cards\r\n    let i;\r\n    for (i = 0; i < tempHandList.length; i++) {\r\n      if (tempHandList[i].length > 0) {\r\n        roundOver = false;\r\n      } \r\n    }\r\n\r\n    if (roundOver === true) {\r\n      this.handleRoundEnd(tempDiscardList)\r\n    }\r\n    \r\n    //Regardless, let's increment the active player and return\r\n    let activePlayer = this.state.activePlayer;\r\n    activePlayer = (activePlayer + 1) % tempHandList.length;\r\n    /*this.setState({\r\n      activePlayer: activePlayer,\r\n    });*/\r\n\r\n    //Update the server\r\n    let tempState = {\r\n      ...this.state,\r\n      activePlayer: activePlayer,\r\n    };\r\n    this.socket.emit(\"CHANGE_STATE\", tempState);\r\n    return;\r\n  }\r\n\r\n  handleRoundEnd(discardList) {\r\n    //first slice out the pileList\r\n    let thisRound = this.state.roundNumber;\r\n    let scoreList = this.state.roundScores.slice();\r\n    let thisRoundList = scoreList[thisRound].slice();\r\n    let tempDiscardList = discardList.slice();\r\n\r\n    //first check if any players have the highest # of a card color\r\n    let suitList = this.state.suitList.slice();\r\n    let topPlayers = Array(suitList.length).fill({\r\n      mostCards: 0, \r\n      player: -1,\r\n    });\r\n    //let tempScores = Array(discardList.length).fill(0);\r\n    //I need to loop through the discardPiles to figure out how scoring works\r\n    let suitCardList = Array(suitList.length).fill( Array(tempDiscardList.length).fill(0) );\r\n    let wildCards = Array(tempDiscardList.length).fill(0);\r\n    let tempCard;\r\n\r\n    let i, j;\r\n    for (i = 0; i < tempDiscardList.length; i++) { \r\n      //Distribute each card appropriately\r\n      while (tempDiscardList[i].cardList.length > 0) {\r\n        //First check for wild\r\n        tempCard = tempDiscardList[i].cardList.pop();\r\n        if (tempCard.suit === \"Wild\") {\r\n          wildCards[i] += this.state.wildPoints;\r\n        } else {\r\n          suitCardList[ suitList.indexOf( tempCard.suit ) ][i] += 1\r\n        }\r\n      }\r\n      \r\n      //Check to see if any are longer than the current best: \r\n      for (j = 0; j < topPlayers.length; j++) {\r\n        if ( suitCardList[ j ][i] > topPlayers[j].mostCards ) {\r\n          topPlayers[j].mostCards = suitCardList[ j ][i] ;\r\n          topPlayers[j].player = i;\r\n          \r\n        } else if (suitCardList[j][i] === topPlayers[j].mostCards ) {\r\n          topPlayers[j].player = -1;\r\n        }\r\n      }\r\n    }\r\n    \r\n    //Now we know who to subtract points from -- let's compute the scores\r\n    for (i = 0; i < thisRoundList.length; i++) {\r\n      //For each player, add their wild card scores\r\n      thisRoundList[i] += wildCards[i];\r\n\r\n      //Then loop through each suit score and then add them\r\n      for (j = 0; j < suitCardList.length; j++) {\r\n        thisRoundList[i] += suitCardList[j][i];\r\n      }\r\n    }\r\n\r\n    //Then loop through the best players and subtract scores from them\r\n    for (i = 0; i < topPlayers.length; i++) {\r\n      if (topPlayers[i].player >= 0) {\r\n        thisRoundList[topPlayers[i].player] -= topPlayers[i].mostCards; \r\n      }\r\n    }\r\n\r\n\r\n    let winner = this.state.winner;\r\n\r\n    //Also need to check if it's the final round, at which point I need to pass end of game\r\n    if (thisRound >= this.state.maxRounds - 1) {\r\n      \r\n      winner = this.checkWinner();\r\n    }\r\n    \r\n  //Update the round numbers, scores, etc.\r\n  //Decrement the active player because of how cards work\r\n  let activePlayer = this.state.activePlayer - 1;\r\n  scoreList[thisRound] = thisRoundList;\r\n  thisRound += 1; \r\n  \r\n  /*this.setState({\r\n    activePlayer: activePlayer,\r\n    roundNumber: thisRound,\r\n    roundScores: scoreList,\r\n    winner: winner,\r\n  });*/\r\n\r\n  //Update the server\r\n  let tempState = {\r\n    ...this.state,\r\n    activePlayer: activePlayer,\r\n    roundNumber: thisRound,\r\n    roundScores: scoreList,\r\n    winner: winner,\r\n  };\r\n  this.socket.emit(\"CHANGE_STATE\", tempState);\r\n\r\n  //If there isn't a winner yet:\r\n  if (winner === null) {\r\n    //reset the board for the next round\r\n    this.resetBoard();\r\n  }\r\n\r\n  return;\r\n}\r\n\r\n  initializeDeck() {\r\n    \r\n    //First fill the card list with wild cards\r\n    let cardList = [];\r\n    let suitList = this.state.suitList.slice();\r\n    let numberList = this.state.numberList.slice();\r\n    \r\n    //Now create the card list\r\n    let i, j;\r\n    for (i = 0; i < suitList.length; i++) {\r\n      for (j = 0; j < numberList.length; j++) {\r\n        cardList.push(   \r\n          {\r\n            id: null,\r\n            name: String(numberList[j]) + \" \" + suitList[i],\r\n            value: numberList[j],\r\n            suit: suitList[i],\r\n            isSelected: false,\r\n          }\r\n        )\r\n      }\r\n    }\r\n\r\n    //Now add the wild cards to the end\r\n    for (i = 0; i < this.state.numWilds; i++) {\r\n      cardList.push( \r\n        {\r\n          id: null, \r\n          name: String(this.state.wildValue) + \" Wild\",\r\n          value: this.state.wildValue,\r\n          suit: 'Wild',\r\n          isSelected: false,\r\n        }\r\n      );\r\n    }\r\n\r\n    //Now give each card a unique id for use later\r\n    for (i = 0; i < cardList.length; i++) {\r\n      cardList[i].id = i;\r\n    }\r\n\r\n    return cardList;\r\n  }\r\n  \r\n  shuffleDeck( deck ) {\r\n    //We need to randomly order the deck\r\n    let tempDeck = [];\r\n    let randInt = 0;\r\n\r\n    while (deck.length > 0) {\r\n      randInt = Math.floor(Math.random() * deck.length);\r\n\r\n      //I THINK that I need this [0] index because splice produces an array????\r\n      tempDeck.push( deck.splice( randInt, 1)[0] )\r\n\r\n    }\r\n\r\n    return tempDeck;\r\n  }\r\n\r\n  dealCards( deck ) {\r\n    //need to distribute the cards to each empty hand....\r\n    let tempHandList = [[], [], [], []];\r\n    let currentHand = this.state.roundNumber; \r\n    let maxHand = 4;\r\n    \r\n    while (deck.length > 0) {\r\n\r\n      //Push the popped deck card into the appropriate player list\r\n      tempHandList[currentHand].push( deck.pop() )\r\n      \r\n      //Now cycle the player\r\n      currentHand = (currentHand + 1) % maxHand;\r\n\r\n    }\r\n\r\n    return tempHandList;\r\n  }\r\n\r\n  initializePiles() {\r\n    let pileList = [\r\n      {\r\n        name: \"CatPile\",\r\n        suit: \"Cat\",\r\n        count: 0,\r\n        cardList: [],\r\n\r\n      },\r\n      {\r\n        name: \"MirrorPile\",\r\n        suit: \"Mirror\",\r\n        count: 0,\r\n        cardList: [],\r\n\r\n      },\r\n      {\r\n        name: \"LadderPile\",\r\n        suit: \"Ladder\",\r\n        count: 0,\r\n        cardList: [],\r\n\r\n      },\r\n    ];\r\n    return pileList;\r\n  }\r\n\r\n  initializeDiscards() {\r\n    let discardList = [\r\n      {\r\n        count: 0,\r\n        cardList: [],\r\n      },\r\n      {\r\n        count: 0,\r\n        cardList: [],\r\n      },\r\n      {\r\n        count: 0,\r\n        cardList: [],\r\n      },\r\n      {\r\n        count: 0,\r\n        cardList: [],\r\n      },\r\n    ];\r\n\r\n    return discardList;\r\n  }\r\n  resetBoard() {\r\n    let orderedDeck = this.initializeDeck();\r\n    let shuffledDeck = this.shuffleDeck( orderedDeck.slice() );\r\n    let playerHands = this.dealCards(shuffledDeck);\r\n    /*this.setState({\r\n      handList: playerHands,\r\n      pileList: this.initializePiles(),\r\n      discardList: this.initializeDiscards(),\r\n    });*/\r\n\r\n    //Update the server\r\n    let tempState = {\r\n      ...this.state,\r\n      handList: playerHands,\r\n      pileList: this.initializePiles(),\r\n      discardList: this.initializeDiscards(),\r\n    };\r\n    this.socket.emit(\"CHANGE_STATE\", tempState);\r\n    return;\r\n  }\r\n  \r\n  render() {\r\n    \r\n    //If this is the start of the game\r\n    if (this.state.handList === null) {\r\n      this.resetBoard();\r\n    }\r\n\r\n    let winnerNumber = this.state.winner;\r\n    \r\n\r\n    //Set the state before starting the game\r\n    \r\n    \r\n\r\n    return (\r\n      <div className=\"board\">\r\n        <h2>Active Player: {this.state.activePlayer + 1}</h2>\r\n        <h3>ScoreList [Round {this.state.roundNumber + 1}]: </h3>\r\n          {this.state.roundScores.map((scoreArray, roundNumber) => (\r\n            roundNumber <= this.state.roundNumber &&\r\n            <h3 key={\"RoundScores\".concat(roundNumber)}>{scoreArray.map((score, scoreIndex) => (\r\n              <span key={\"Score\".concat(scoreIndex)}>{score}   </span>\r\n            ))}</h3>\r\n          ))}\r\n        <Board \r\n          //I think all these things should be put into the Board Class\r\n          playerHandList={this.state.handList} \r\n          pileList={this.state.pileList}\r\n          discardList={this.state.discardList}\r\n          //activePlayer can be passed so that we can update the class of the boards\r\n          //\r\n          activePlayer={this.state.activePlayer}\r\n          suitOrder={this.state.suitList}\r\n          overflowNumber={this.state.overflowNumber}\r\n          onTurnEnd={(handList, discardList) => this.handleTurnEnd(handList, discardList)}\r\n          renderPileList={() => this.renderPileList()}\r\n          renderHandList={() => this.renderHandList()}\r\n          renderDiscardList={() => this.renderDiscardList()}\r\n\r\n        />\r\n\r\n\r\n    \r\n        { winnerNumber > 0 &&\r\n\r\n          <h2>Congratualtions, Player {this.state.winner + 1} </h2>\r\n\r\n        }\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nReactDOM.render(\r\n  <Router onUpdate={() => window.scrollTo(0, 0)}>\r\n    <Route path=\"/\" component={ Game } />\r\n  </Router>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n\r\n/*import React, {useContext, useState, useEffect} from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\n\r\n\r\nimport { BrowserRouter as Router, Route, Redirect, useLocation} from 'react-router-dom';\r\nimport Store, {Context} from './Store';\r\n\r\nimport io from \"socket.io-client\";\r\n\r\n//so this one is going to be the top level? \r\n//It's going to store the counter\r\n\r\nconst Game = () => {\r\n  //const {state, dispatch} = useContext(Context);  \r\n  const {pathname, searc} = useLocation();\r\n  const name = pathname.slice(1,)\r\n  console.log(\"NAME: \", name)\r\n  const socket = io('localhost:5000');\r\n  const [state, setState] = useState(0);\r\n\r\n  useEffect(() => {\r\n    socket.emit('GET_COUNT', {\r\n      name: name,\r\n    });\r\n  });\r\n\r\n  socket.on('UPDATE_COUNT', (newCount) => {\r\n    setState(newCount);\r\n  });\r\n  \r\n  const incrementCount = (name) => {\r\n    socket.emit('INCREMENT_COUNT', {\r\n      name: name,\r\n    });\r\n  }\r\n\r\n  return (\r\n          <div className=\"Game\">\r\n          <h3> Welcome to page {name}</h3>\r\n          {//<h3>The count is {state.stateHolder[props.name].count}</h3>\r\n          }\r\n          <h3>The count is {state}</h3>\r\n          <button onClick={() => {\r\n              //dispatch({type: 'INCREMENT_COUNT', payload: props.name}); \r\n              incrementCount(name);\r\n            }  \r\n          }>Click to raise count</button>\r\n          </div>\r\n      );\r\n  };\r\n\r\n\r\n\r\nconst Controller = () => {\r\n  //const {stateHolder, dispatch} = useContext(Context);\r\n\r\n  const socket = io('localhost:5000');\r\n\r\n  let wordArray = [\r\n    'first',\r\n    'second', \r\n    'third',\r\n    'fourth',\r\n    'fifth',\r\n  ];\r\n\r\n  const randomName = () => {\r\n      \r\n    let i, wordURL=\"\", tempRand, tempLength;\r\n    tempLength = wordArray.length;\r\n\r\n\r\n    for (i = 0; i < 2; i++) {\r\n      tempRand = Math.floor(Math.random() * tempLength);\r\n\r\n        wordURL += wordArray[tempRand];\r\n        \r\n    }\r\n    return wordURL;\r\n  }\r\n\r\n  const [textValue, setTextValue] = useState(randomName);\r\n\r\n  \r\n  return ( \r\n\r\n      <div>\r\n        <div>Enter Room Code:\r\n              <input type=\"text\" name=\"inputtext\" value={textValue} onChange={\r\n                (event) => {\r\n                  setTextValue(event.target.value);\r\n                }}/>\r\n              <button onClick={() => {\r\n                alert(\"Clicked\");\r\n                //dispatch({type: 'ADD_PLACE', payload: textValue});\r\n                socket.emit('ADD_PLACE', {\r\n                  name: textValue,\r\n                });\r\n                return(\r\n                  <Redirect to={\"/\"+textValue} />\r\n                );\r\n            }}>Start Game</button>     \r\n        </div>               \r\n      </div>\r\n    \r\n    );\r\n  }\r\n\r\nconst App = () => {\r\n  //const {stateHolder, dispatch} = useContext(Context);\r\n  //DECLARE ALL THE SOCKETS TO UPDATE THE STATE LIST\r\n  const socket = io('localhost:5000');\r\n  const [state, setState] = useState({});\r\n\r\n  socket.on('RECEIVE_PLACE', (stateHolder) => {\r\n    setState(stateHolder);\r\n  });  \r\n  socket.on('UPDATE_PLACE', (stateHolder) => {\r\n    setState(stateHolder);\r\n  });  \r\n  let returnList = [];\r\n  if (state) {\r\n\r\n    const stateList = Object.entries(state);\r\n\r\n\r\n    returnList = Object.keys(state).map((key) => {\r\n      return(\r\n        <Route exact\r\n          key={String(key)}\r\n          path={\"/\"+String(key)} \r\n          component={ Game }\r\n      />\r\n      );\r\n    });\r\n  }\r\n\r\n  return(\r\n    <Router onUpdate={() => window.scrollTo(0, 0)}>\r\n      <Route exact path=\"/\" component={ Controller } />\r\n      {returnList}\r\n    </Router>\r\n  );\r\n};\r\n\r\nReactDOM.render(\r\n      <App />,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n*/\r\n\r\n"],"sourceRoot":""}